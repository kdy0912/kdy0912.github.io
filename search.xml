<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理——CPU子系统</title>
      <link href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94CPU%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94CPU%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>CPU基本组成</h1><h2 id="模型机数据通路框图">模型机数据通路框图</h2><p><img src="https://s2.loli.net/2022/10/17/jJFw5CuOKX2evGk.png" alt="cpu.png"></p><h2 id="各种寄存器的作用">各种寄存器的作用</h2><ol><li><p>通用寄存器组：一组可编程访问的寄存器。在指令系统中为这些R分配了编号，有：R0~R3，PC，SP，PSW。</p></li><li><p>暂存器：用户不能直接访问，用来暂存信息，在指令系统中没有为它们分配编号，有C、D。</p><p>暂存器C：从主存中读取源操作数或源操作数地址时，使用它。</p><p>暂存器D：从主存中读取目的作数或目的操作数地址时，或中间运算结果时，使用它。</p></li><li><p>指令寄存器IR：用来存放现行运行指令，它的输出是产生微操作命令序列的主要逻辑依据。为了提高读取指令的速度，在主存与IR间建立直接传送通路，并且将IR扩充为指令队列（或指令栈），允许预取若干条指令。</p></li><li><p>程序计数器PC：PC提供后继指令地址，并送往与主存器相连接的地址寄存器（MAR）。后继指令地址=PC+n，模型机中为了简化起见，令n=1。</p></li><li><p>程序状态字寄存器PSW：PSW的内容就是表现的现行程序的状态。包括：特征位；编程设定位。</p></li><li><p>用作主存接口的寄存器：地址寄存器MAR、 数据缓冲寄存器MBR(MDR)，CPU访问主存时，首先送出地址码，然后送出/接收数据，当作用在MAR上的微命令EMAR为低电平时，MAR输出呈高阻态，与地址总线断开；当作用在MAR上的微命令EMAR为高电平时，MAR输出其内容（地址信息）送往地址总线。</p><p>地址寄存器MAR：读取指令/存取操作数/操作数地址时，CPU先将地址信息送入MAR，再由MAR经地址总线送往主存M，找到相应的主存单元。</p><p>数据缓冲寄存器MBR(MDR)由控制命令R/W决定传送方向。</p><p>R：由主存单元→数据总线→MDR</p><p>W：由MDR→数据总线→数据单元</p></li></ol><h1>寻址方式</h1><h2 id="常见寻址方式">常见寻址方式</h2><ol><li><p>立即寻址：在读取指令时也就从指令之中获得了操作数，即操作数包含在指令中。指令中在操作码字段后面的部分不是通常意义上的操作数地址，而是操作数本身，也就是在取出指令的同时也就取出了可以立即使用的操作数。</p></li><li><p>直接寻址（主存直接寻址）：若指令中给出的地址码是主存的某个单元号，操作数存放在该指定的主存单元中,这种寻址方式称为直接寻址或主存直接寻址方式。</p></li><li><p>寄存器直接寻址：若指令中给出的地址码是寄存器编号，操作数存放在该指定的寄存器中,这种寻址方式称为寄存器寻址或寄存器直接寻址方式。</p></li><li><p>间接寻址（主存间接寻址）：若操作数存放在主存某个存储单元中，则该主存单元的地址被称为操作数地址。</p><p>若操作数地址存放在另一主存单元之中（不是由指令直接给出），则该主存单元被称为间址单元，间址单元本身的地址被称为操作数地址的地址。</p><p>若指令中地址给出的是间址单元地址（即操作数地址的地址，而不是操作数地址，且在主存），从中读取操作数地址，按照操作数地址再次访问主存，从相应单元中读写操作数，这种寻址方式称为间接寻址或主存间接寻址方式。</p></li><li><p>寄存器间接寻址：若指令中给出的地址码是寄存器编码，被指定的寄存器中存放的是操作数地址，按照该地址访问某主存单元，该单元的内容为操作数，这种寻址方式称为寄存器间接寻址。</p></li><li><p>自增型寄存器间址：寄存器间址的一种变型,若指令中给出存放操作数地址的寄存器号,从寄存器中读出操作数地址后,寄存器内容加1。</p></li><li><p>自减型寄存器间址：寄存器间址的又一种变型。若指令中给出寄存器号，被指定的寄存器内容减1后作为操作数地址，按照该地址访问主存储器，相应的主存单元内容为操作数。</p></li><li><p>堆栈寻址：堆栈寻址方式是指操作数在堆栈中，指令隐含约定由堆栈指针SP寄存器提供栈顶单元地址（SP也可以编码形式出现在指令中），进行读出或写入的一种寻址方式。根据压入数据时栈顶单元的地址是减小还是增大或不变,可以将堆栈的工作方式大致分为向上生成方式、向下生成方式和栈顶固定方式三种。</p></li><li><p>多重间接寻址（主存多重间接寻址）：根据指令找到间址单元,其中的内容还不是操作数地址,而是又一层间址单元的地址；根据该地址访问又一层间址单元,取出来的才是操作数地址(存放操作数的存储单元的地址码)。多重间址有分为寄存器多重间址与存储器多重间址。</p></li><li><p>变址寻址：若指令中给出变址寄存器号和一个形式地址,变址寄存器的内容(称为变址量)与形式地址相加,得到操作数有效地址(即操作数实际地址),按照有效地址访问某主存单元,该单元的内容即为操作数,这种寻址方式称为变址寻址。</p></li><li><p>基址寻址：若指令中给出基址寄存器号和一个形式地址，基址寄存器内容（作为基准地址）与形式地址（作为位移量）相加，其和为操作数有效地址(即操作数实际地址)，按照该地址访问主存储器，该单元的内容即为操作数，这种寻址方式称为基址寻址。</p></li></ol><p><img src="https://s2.loli.net/2022/10/17/tm3DVoh4IrqWFUX.png" alt="基变寻址.png"></p><h2 id="模型机寻址方式">模型机寻址方式</h2><ol><li>寄存器寻址 R</li><li>寄存器间址 （R）寄存器内容是操作数地址</li><li>自减型寄存器间址  -（R）先减后取</li><li>自增型寄存器间址（R）+  先取后加</li><li>变址寻址 X（R）寄存器内容=位移量+基准地址</li><li>双重间址 @（R）+  寄存器内容是操作数地址的地址</li></ol><p><img src="https://s2.loli.net/2022/10/17/TAlB3ChGwpnHIZW.png" alt="模型机寻址.png"></p><h1>CPU指令流程</h1><h2 id="取指周期FT">取指周期FT</h2><p>所有指令的公共操作</p><p>M → IR ，PC + 1 → PC</p><h2 id="MOV指令">MOV指令</h2><table><thead><tr><th></th><th>( R )</th><th>-( R )</th><th>( R )+</th><th>@( R )+</th><th>X( R )</th></tr></thead><tbody><tr><td>ST0</td><td>Ri → MAR</td><td>Ri - 1 → Ri , MAR</td><td>Ri → MAR</td><td>Ri → MAR</td><td>PC→MAR</td></tr><tr><td>ST1</td><td>M → MDR → C</td><td>M → MDR → C</td><td>M → MDR → C</td><td>M → MDR → C</td><td>M → MDR → C</td></tr><tr><td>ST2</td><td></td><td></td><td>Ri + 1 → Ri</td><td>Ri + 1 → Ri</td><td>PC + 1 → PC</td></tr><tr><td>ST3</td><td></td><td></td><td></td><td>C → MAR</td><td>C + Ri → MAR</td></tr><tr><td>ST4</td><td></td><td></td><td></td><td>M → MDR → C</td><td>M → MDR → C</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>DT0</td><td>Rj  →  MAR</td><td>Rj - 1 → Rj , MAR</td><td>Rj → MAR</td><td>Rj → MAR</td><td>PC → MAR</td></tr><tr><td>DT1</td><td></td><td></td><td>Rj + 1→ Rj</td><td>Rj + 1 → Rj</td><td>M → MDR → D</td></tr><tr><td>DT2</td><td></td><td></td><td></td><td>M → MDR → MAR</td><td>PC + 1 → PC</td></tr><tr><td>DT3</td><td></td><td></td><td></td><td></td><td>D + Rj → MAR</td></tr></tbody></table><table><thead><tr><th></th><th>$SR · DR $</th><th>$SR · \overline{DR}$</th><th>$\overline{SR}·DR $</th><th>$\overline{SR}·\overline{DR}$</th></tr></thead><tbody><tr><td>ET0</td><td>Ri → Rj</td><td>Ri → MDR</td><td>C → Rj</td><td>C → MDR</td></tr><tr><td>ET1</td><td></td><td>MDR → M</td><td></td><td>MDR → M</td></tr></tbody></table><p>ET的最后一步一定是 PC → MAR</p><h2 id="双操作数指令">双操作数指令</h2><p>其中取指令和取源操作数与MOV指令相同</p><table><thead><tr><th></th><th>( R )</th><th>-( R )</th><th>( R )+</th><th>@( R )+</th><th>X( R )</th></tr></thead><tbody><tr><td>ST0</td><td>Ri → MAR</td><td>Ri - 1 → Ri , MAR</td><td>Ri → MAR</td><td>Ri → MAR</td><td>PC→MAR</td></tr><tr><td>ST1</td><td>M → MDR → C</td><td>M → MDR → C</td><td>M → MDR → C</td><td>M → MDR → C</td><td>M → MDR → C</td></tr><tr><td>ST2</td><td></td><td></td><td>Ri + 1 → Ri</td><td>Ri + 1 → Ri</td><td>PC + 1 → PC</td></tr><tr><td>ST3</td><td></td><td></td><td></td><td>C → MAR</td><td>C + Ri → MAR</td></tr><tr><td>ST4</td><td></td><td></td><td></td><td>M → MDR → C</td><td>M→MDR→C</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>DT0</td><td>Rj  →  MAR</td><td>Rj - 1 → Rj , MAR</td><td>Rj → MAR</td><td>Rj → MAR</td><td>PC → MAR</td></tr><tr><td>DT1</td><td>M → MDR → D</td><td>M → MDR → D</td><td>M → MDR → D</td><td>M → MDR → D</td><td>M → MDR → D</td></tr><tr><td>DT2</td><td></td><td></td><td>Rj + 1→ Rj</td><td>Rj + 1 → Rj</td><td>PC + 1 → PC</td></tr><tr><td>DT3</td><td></td><td></td><td></td><td>D → MAR</td><td>D + Rj → MAR</td></tr><tr><td>DT4</td><td></td><td></td><td></td><td>M → MDR → D</td><td>M → MDR → D</td></tr></tbody></table><table><thead><tr><th></th><th>$SR · DR $</th><th>$SR · \overline{DR}$</th><th>$\overline{SR}·DR $</th><th>$\overline{SR}·\overline{DR}$</th></tr></thead><tbody><tr><td>ET0</td><td>Ri OP Rj → Rj</td><td>Ri OP D → MDR</td><td>C OP Rj → Rj</td><td>C OP D → MDR</td></tr><tr><td>ET1</td><td></td><td>MDR → M</td><td></td><td>MDR → M</td></tr></tbody></table><p>ET的最后一步一定是 PC → MAR</p>]]></content>
      
      
      <categories>
          
          <category> 专业知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——数值型数据的表示方法</title>
      <link href="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA/"/>
      <url>/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1>进位计数制及其相互转换</h1><h2 id="构成进位计数制的两个基本要素">构成进位计数制的两个基本要素</h2><p>基数：每个数位中所允许的最大数码值+1或每个数位中所允许的最多数码个数。<br>权：是一个与所在数位相关的常数。<br>权与基数的关系：相邻两位的权值之比等于基数值。<br>二进制：权是2、基数是0、1<br>十进制：权是10、基数是0、1、2、3、4、5、6、7 、8、9<br>十六进制：权是16、基数是0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F</p><h2 id="各种进位计数制的相互表示">各种进位计数制的相互表示</h2><ol><li>十进制数转换为二进制数：整数部分除以2取余数，所得余数为二进制整数低位的值，继续操作直到商为0为止。小数部分乘以2取整数，所得整数部分为二进制小数高位的值，继续对所余小数操作，直到小数为0(或到达要求精度)为止。</li><li>二进制数转换为十进制数：按权位展开求和。</li><li>八进制、十六进制与二进制数的转换：从小数点起每三位（四位）一组，整数部分不够三位（四位）时在前面添0，小数部分不够三位（四位）时在后面添0。转二进制就反过来操作。</li><li>十进制数与八进制数、十六进制数间的转换：和前两条道理相同，略。</li></ol><h1>带符号数的表示</h1><ol><li><p>真值：正、负符号加绝对值表示数值。</p></li><li><p>机器数：在计算机内部使用的，连同数符一起数码化了的数。分类：原码、补码、反码。</p></li><li><p>原码：又称“符号－数值表示”，在以原码表示的正负数中，第一位为0(正数)；为1(负数)。<br>若 X = -1011，则五位字长的 $X_原$ = 11011，而八位字长的 $X_原$ = 10001011。</p><p>(1) 在原码表示中，真值 0 可以有两种不同的表示形式，可分别称为+0 与-0。<br>[+$X_原$] = 0.00…0，[-$X_原$] = 1.00…0 。它们的真值含义相同。</p><p>(2) 对于小数原码，表示范围：$-1&lt;X&lt;1$；对于整数原码 $X_n X_{n-1} …X_0$，表示范围：$-2^n &lt; X&lt;2^n$。</p><p>(3) 符号位不是数值的一部分，是人为地约定“0正1负”。所以在原码运算中需将符号位与有效数值部分分开处理，也就是取数的绝对值进行运算（又称为无符号数运算），而符号位单独处理。</p></li><li><p>补码：如果数为正，则正数的补码与原码表示形式相同；如果数为负，则将负数的原码<strong>除符号位外</strong>，其余各位取反后末尾再加1。<br>(1) $X_补 = M + X (mod M)$<br>式中，模为M，X是真值；$X_补$是数X的补码。若$X≥0$，模M可作为溢出量舍去，如同在时钟一例中舍去模12一样，则$X_补$=X。若X＜0，则$X_补=M+X =M-|X|$。</p><p>(2) 定点小数的补码定义式：若定点小数的补码序列为 $ X_0.X_1X_2…X_n $，其溢出量为 $2^1$（注意：符号位 $X_0$的权值是 $2^0$），因此以2为模。</p><p>(3) 定点整数的补码定义式：若定点整数的补码序列为 $X_n X_{n-1} …X_0$，即连同符号位有n+1位，其溢出量为$2^{n+1} $（注意：符号位 $X_n$的权值是$2^n$），因此以 $2^{n+1}$为模。</p></li><li><p>反码：又称“1的补码”，用反码表示时，左边的第一位也为符号位，0代表正数，1代表负数。对于负数，反码的数值是将原码数值部分按位求反，符号位1保持不变。而对于正数，反码和原码相同。</p></li><li><p>定点表示法：在计算机中，小数点位置固定不变的数称为定点数。表示数的范围和分辨率固定不变。<br>a.无符号定点整数：略去符号位的正整数。<br>b.带符号定点整数：是纯整数，小数点在最低位之后，最高位为符号位。<br>c.带符号定点小数：是纯小数，用原码或补码表示。</p></li><li><p>浮点表示法：<br>(1) 浮点数的格式：$N = ± R^E ×M$<br>式中N为真值， $R^E$为比例因子，M是尾数。对于某种浮点格式，R固定不变且隐含约定，因此浮点数代码序列中只需分别给出E和M两部分（连同它们的符号）。</p><p>(2) 移码：若阶码（连同一位阶符）共 m+1 位，代码序列为 $X_m X_{m-1} …X_0$<br>则$X_移=2^m+X （-2^m &lt; X&lt;2^m）$<br>式中X是阶码的真值，$2^m$是符号位 $X_移$ 的位权。因此$X_移$相当于将真值X沿数轴正向平移$2^m$，<br>所以称为移码。或者说将X增加$2^m$，所以又取名为增码。</p></li><li><p>补充</p><p><img src="https://s2.loli.net/2022/10/05/XPKFIeYzgymJV8x.jpg" alt="真值、标准移码、补码对照表"></p></li></ol><h1>IEEE754标准浮点格式</h1><p><img src="https://s2.loli.net/2022/10/05/uLIMvcKwfagrWUi.jpg" alt="IEEE754短浮点数格式"></p>]]></content>
      
      
      <categories>
          
          <category> 专业知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用语法汇总（一）</title>
      <link href="/2022/09/12/Java%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2022/09/12/Java%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1>数组相关</h1><h2 id="数组的初始化">数组的初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];  <span class="comment">//动态初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">//静态初始化完整版</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  <span class="comment">//静态初始化简略版</span></span><br></pre></td></tr></table></figure><h2 id="获取数组长度">获取数组长度</h2><p>直接使用<code>数组名.length</code></p><h2 id="Arrays类中的方法介绍">Arrays类中的方法介绍</h2><ol><li><code>Arrays.sort(Object[] arr)</code>:对数组从小到大排序</li><li><code>Arrays.sort(Object[] arr, int start, int end)</code>：范围内对数组排序，左闭右开</li><li><code>Arrays.fill(Object[]arr, Object obj)</code>：填充相同元素</li><li><code>Arrays.equal(Object[] arr1,Object[] arr2)</code>：判断两个数组内容是否相同</li><li><code>Arrays.copyOf(Object[] arr)</code>：拷贝数组，返回一个新数组</li><li><code>Arrays.copyOfRange(Object[] arr, int from, int to)</code>：拷贝数组，指定起始位置和结束位置，如果超过原数组长度，会用null进行填充</li><li><code>Arrays.toString(Object[] arr)</code>：将数组中的内容全部打印出来</li><li><code>Arrays.binarySearch(Object[] arr, Object obj)</code>：二分查找法找指定元素的索引值(数组一定是排好序的，否则会出错。找到元素，只会返回最后一个位置)</li></ol><h1>字符串相关</h1><h2 id="长度相关">长度相关</h2><ol><li><code>length()</code>：获取字符串长度</li></ol><h2 id="判断相关">判断相关</h2><ol><li><code>contains(String)</code>：判断一个字符串中是否包含指定内容</li><li><code>startsWith(String)</code>和<code>endsWith(String)</code>：判断一个字符串是否以指定内容开头或结尾</li></ol><h2 id="位置相关">位置相关</h2><ol><li><code>charAt(int)</code> ：得到指定下标位置的字符，通常用于字符串的遍历</li><li><code>indexOf(string/char)</code>和<code>lastIndexOf(string/char)</code>：得到指定位置第一次出现和最后一次出现的下标</li><li><code>indexOf(string/char, fromIndex)</code>:得到从指定位置开始的第一次出现的下标</li></ol><h2 id="内容相关">内容相关</h2><ol><li><code>equals(String)</code>：比较字符串内容是否相同</li><li><code>toUpperCase()</code>和<code>toLowerCase()</code>：将字符串全部转换为大写或小写</li><li><code>replace(String, String)</code>：将某个内容全部替换为某个内容</li><li><code>substring(int, int)</code>：返回截取内容的字符串，从x到y-1</li></ol><h2 id="数组相关">数组相关</h2><ol><li><code>split(String)</code>：按指定字符（串）分割某个字符串，结果以字符串数组形式返回</li><li><code>toCharArray()</code> ：将字符串转换为字符数组</li><li><code>void getChars(int sourceStart, int sourceEnd, char[] target, int targetStart)</code>:截取多个字符,<br>子串包含从sourceStart到sourceEnd-1的字符。接收字符的数组由target指定，target中开始复制子串的下标值是targetStart</li></ol><h2 id="与基本数据的转化">与基本数据的转化</h2><ol><li><code>parseInt(String s)</code>：将数字格式的<strong>字符串转换为int</strong> （byte、short、long、<br>float、double）型数据。<br>例： <code>int x; String s = &quot;123456&quot;; x = Integer.parseInt(s);</code></li><li><code>public static String valueOf(int （byte、short、long、float、double） n)</code>：<strong>将int（byte、short、long、float、double）型数值转换为字符串</strong>.<br>例：<code>String str = String.valueOf(1234.789);</code></li></ol><h1>StringBuilder类中常用方法</h1><ol><li>StringBuilder的构造方法：<br><code>public StringBuilder()</code>:无参构造方法<br><code>public StringBuilder(int capacity)</code>:指定容量的字符串缓冲区对象<br><code>public StringBuilder(String str)</code>:指定字符串内容的字符串缓冲区对象</li><li><code>public int capacity()</code>:返回当前容量,理论值<br><code>public int length()</code>:返回长度(字符数),实际值（一般用这个）</li><li><code>public StringBuilder append(String str)</code>:可以把<strong>任意类型数据</strong>添加到字符串缓冲区里面，并返回字符串缓冲区本身<br><code>public StringBuilder insert(int offset,String str)</code>:在指定位置把<strong>任意类型数据</strong>插入到字符串缓冲区里面，并返回字符串缓冲区本身</li><li><code>char charAt(int index)</code>：获取指定索引出的字符</li><li><code>public StringBuilder delete(int start,int end)</code>：删除起始位置（含）到结尾位置（不含）之间的字符串</li><li>StringBuilder的截取功能：注意返回值类型是String，不是StringBuilder<br><code>public String substring(int start)</code><br><code>public String substring(int start,int end)</code></li><li>StringBuilder的替换功能：<br><code>public StringBuilder replace(int start,int end,String str)</code>:从start到end用str替换,同样为左闭右开</li><li>StringBuilder的反转功能：<br><code>public StringBuilder reverse()</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理——概论</title>
      <link href="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%A6%82%E8%AE%BA/"/>
      <url>/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1>计算机系统的基本组成与特点</h1><br><ol><li>计算机的五大组成部分：运算器、控制器、存储器、输入设备、输出设备（包括总线、接口）</li><li>计算机内部的两大流：控制流、数据流</li><li>冯·诺依曼体制：采用二进制表示数据和指令、<strong>采用存储程序方式工作</strong>（核心）、由五大部分组成计算机系统的硬件，并规定了这五部分的基本功能</li></ol><br><h1>计算机系统的硬件组成</h1><br><h2 id="主要组成部件">主要组成部件</h2><ol><li>存储器</li><li>CPU：由运算器、控制器组成，控制器产生控制命令(微命令)，控制全机操作</li><li>输入/输出设备，功能为转换信息</li></ol><h2 id="硬件系统结构">硬件系统结构</h2><ol><li>以总线为基础的系统结构</li><li>采用通道或IOP的大型系统结构</li><li>模型机系统结构</li><li>接口</li></ol><br><h1>计算机系统的性能指标</h1><br><h2 id="基本字长">基本字长</h2><p>一般是指参加一次定点运算的操作数的位数。如：8、16、32、64位，它影响计算精度、指令功能。</p><h2 id="运算速度">运算速度</h2><ol><li>CPU主频：是计算机的振荡器输出的脉冲序列的频率，是计算机中一切操作所依据的时间基准信号，其高低决定了计算机工做速度的快慢。</li><li>时钟频率：是主频脉冲经分频后所形成的时钟脉冲序列的频率，两个相邻时钟脉冲之间的间隔时间是一个时钟周期时间，也称为节拍。</li></ol><h2 id="数据通路宽度与数据传输率">数据通路宽度与数据传输率</h2><ol><li>数据通路宽度：指数据总线一次能并行传送的数据位数</li><li>数据传输率：指数据总线每秒传送的数据量，也称为数据总线的带宽</li><li>公式：总线带宽 = 总线数据通路宽度 × 总线时钟频率 ÷ 8 （BPS）</li></ol><h2 id="存储容量">存储容量</h2><ol><li>主存容量：存储单元个数 × 位数，表示为：字数×字长（按字编址）或字节数（按字节编址）</li><li>外存容量：表示为字节数，与地址码位数无关</li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法与hexo常用命令</title>
      <link href="/2022/09/09/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/09/09/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1>Markdown基本语法</h1><p>官方教程：<a href="https://markdown.com.cn/basic-syntax/">https://markdown.com.cn/basic-syntax/</a><br>更详细语法的链接：<a href="https://zhuanlan.zhihu.com/p/99319314">https://zhuanlan.zhihu.com/p/99319314</a></p><p><strong>两个星号可以加粗</strong>，<em>一个星号是斜体</em>。</p><p>无序列表是短横线，有序列表是数字加英文句号，记得加空格。</p><ul><li>无序列表1</li><li>无序列表2</li></ul><ol><li>有序列表1</li><li>有序列表2</li></ol><hr><h2 id="二级标题1">二级标题1</h2><blockquote><p>这是一段引用，大于号加空格为引用。</p></blockquote><p>这是一个<a href="http://www.baidu.com">链接</a>，链接名字用方括号，后面具体链接用小括号。</p><p>行内代码用一对反引号。 <code>Ctrl + /</code></p><h3 id="三级标题">三级标题</h3><p>代码块：用三个反引号括住，第一行写所用的语言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="二级标题2">二级标题2</h2><p>图片就是链接前面加了个感叹号。<br><img src="https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png" alt="百度"></p><hr><h1>hexo常用命令</h1><br>  <p><code>hexo n &quot;title&quot;</code> 创建新文章<br><code>hexo g -d</code>生成静态文件（gnerate），且文件生成后立即部署网站（deploy）<br><code>hexo publish &quot;title&quot;</code> 发表草稿<br><code>hexo s</code>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a><br><code>hexo clean</code> 清除缓存文件 (db.json) 和已生成的静态文件 (public)，在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令；</p>]]></content>
      
      
      <categories>
          
          <category> 课外拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
